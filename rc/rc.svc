#!/bin/sh
#
# Copyright (c) 2018 Johnothan King. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# /etc/leaninit.d/rc.svc - Functions and variables for execution of LeanInit scrips
#

# Load /etc/profile and /etc/leaninit.d/rc.conf
. /etc/profile
. /etc/leaninit.d/rc.conf

# Set a consistent PATH variable
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

# Color variables
RESET='\033[0m'
RED='\033[1;31m'
BLUE='\033[1;34m'
YELLOW='\033[1;33m'
GREEN='\033[1;32m'
PURPLE='\033[1;35m'
CYAN='\033[1;36m'
WHITE='\033[1;37m'

# Make sure $LOGFILE is set
if [ ! -n "$LOGFILE" ]; then
	LOGFILE=/var/log/leaninit.log
fi

# Execute if exists
exifex() {
	type $1 >> /dev/null
	if [ $? = 0 ]; then
		$*
	fi
}

# Print output to stdout with formatting and to a log file (use this instead of echo)
print() {
	printf "${3}%s ${4}%s${RESET}\n" "*" "${1}"
	if [ "$2" = "log" ]; then
		echo "$1" >> "$LOGFILE"
	fi
}

# Check for uid 0
__rootcheck() {
	if [ "$(id -u)" != "0" ]; then
		print "This must be run as root!" nolog ${RED}
		exit 4
	fi
}

# Used for checking $TARGET
__oscheck() {
	if [ -n "$TARGET" ] && [ "$TARGET" != "$(uname)" ]; then
		print "$NAME could not be ${1}d because the target OS ($TARGET) does not match the current OS ($(uname))!" log ${RED}
		__fail 5
	fi
}

# Checks for $__svcname.status
__svccheck() {
	if [ ! -r "/var/run/leaninit/$__svcname.status" ]; then
		print "$NAME is not running!" nolog ${RED}
		exit 7
	fi
}

# Change the status of a service to 'Failure', then exit with the specified exit code
__fail() {
	echo 'Failure' > "/var/run/leaninit/$__svcname.status"
	exit $1
}

# Show init script usage info
__usage() {
	echo "Usage: /etc/leaninit.d/svc.d/$__svcname [enable|disable|start|stop|restart|try-restart|force-reload|reload|status]"
	echo "Valid actions:"
	echo "  enable"
	echo "  disable"
	echo "  start"
	echo "  stop"
	echo "  restart"
	echo "  force-reload"
	echo "  reload"
	echo "  status"
DEFBSD
	echo "  info"
ENDEF
	exit 1
}

# Wait for a file
__waitfor_loop_file() {
	__TIMER=0
	while true; do
		if [ -r "$1" ]; then break; fi
		sleep 0.1
		__TIMER=$(expr $TIMER + 1)
		if [ $__TIMER = 70 ]; then
			print "$2" log ${RED}
			__fail 1
		fi
	done
	if [ -n "$3" ] && [ "$(cat $1)" = "Failure" ]; then
		print "$3" log ${RED}
		__fail 1
	fi
}

# Wait for a process
__waitfor_loop_proc() {
	__TIMER=0
	while true; do
		if [ -n "$(pgrep -x $1)" ]; then break; fi
		sleep 0.1
		__TIMER=$(expr $TIMER + 1)
		if [ $__TIMER = 70 ]; then
			if [ "$3" != "return" ]; then
				print "$2" log ${RED}
				__fail 1
			else
				return 1
			fi
		fi
	done
}

# Wait for either a file, process, or service for up to seven seconds
waitfor() {
	case "$1" in
		file)
			if [ ! -n "$2" ]; then
				echo "Usage: waitfor type name..."
				return 1
			fi
			__waitfor_loop_file "$2" "$NAME failed to start because the file $2 was not created!"
			;;
		process)
			if [ ! -n "$2" ]; then
				echo "Usage: waitfor type name..."
				return 1
			fi
			__waitfor_loop_proc "$2" "$NAME failed to start because the process $2 failed to start!" "$3"
			;;
		service)
			if [ ! -n "$2" ]; then
				echo "Usage: waitfor type name..."
				return 1
			fi
			if [ ! -r "/etc/leaninit.d/svc.e/$2" ]; then
				if [ "$3" = "optional" ]; then
					return 0
				else
					print "$NAME failed to start because the service $2 is not enabled!" log ${RED}
					__fail 1
				fi
			fi
			__waitfor_loop_file "/var/run/leaninit/$2.status" "$NAME failed to start because the service $2 took too long to start!" "$NAME failed to start because the service $2 failed to start!"
			;;
		*)
			if [ ! -r "/etc/leaninit.d/svc.e/$1.type" ]; then
				if  [ "$2" != optional ]; then
					print "$NAME failed to start because no currently enabled services satisfy the type $1!" log ${RED}
					__fail 1
				else
					return 0
				fi
			fi
			__waitfor_loop_file "/var/run/leaninit/$1.type" "$NAME failed to start because $(cat /etc/leaninit.d/svc.e/$1.type) failed to start!"
			;;
	esac
	return $?
}

# Start a service
__start() {
	# Return if the service is active
	__rootcheck
	if [ -r "/var/run/leaninit/$__svcname.status" ]; then
		print "$NAME is already running..." nolog ${PURPLE} ${YELLOW}
		return 0
	elif [ -n "$TYPE" ] && [ -r "/var/run/leaninit/$TYPE.type" ]; then
		print "$(cat /var/run/leaninit/$TYPE.type) is currently running and conflicts with $NAME!" nolog ${RED}
		return 1
	fi

	# Run main()
	print "Starting $NAME..." log ${BLUE} ${WHITE}
	main 2> "$LOGFILE.2"

	# Finish by creating the service's .status and .type files
	RET=$?
	if [ $RET = 0 ]; then
		print "Started $NAME successfully!" log ${GREEN} ${WHITE}
		echo "Started" > "/var/run/leaninit/$__svcname.status"
		if [ -n "$TYPE" ]; then
			echo "$__svcname" > "/var/run/leaninit/$TYPE.type"
		fi
	else
		print "$NAME failed to start!" log ${RED}
		echo "Failure" > "/var/run/leaninit/$__svcname.status"
	fi
	return $RET
}

# Stop a service
__stop() {
	# Return if the service is not active
	__rootcheck
	if [ ! -r "/var/run/leaninit/$__svcname.status" ]; then
		print "$NAME is not running..." nolog ${PURPLE} ${YELLOW}
		return 0
	fi

	# Stop $DAEMON
	if [ -n "$DAEMON" ] && [ -n "$(pgrep -x $DAEMON)" ]; then
		print "Sending $NAME SIGCONT and SIGTERM..." log ${BLUE} ${WHITE}
		pkill -x -CONT $DAEMON
		pkill -x -TERM $DAEMON
		until pkill -0 -x $DAEMON; do
			sleep 7
			print "Sending $NAME SIGKILL..." log ${PURPLE} ${YELLOW}
			pkill -KILL -x $DAEMON
			break
		done
	fi

	# Execute stop()
	exifex stop

	# Remove the .status and .type files for the service
	rm -f "/var/run/leaninit/$__svcname.status"
	if [ -n "$TYPE" ]; then
		rm -f "/var/run/leaninit/$TYPE.type"
	fi

	# Finish
	print "Stopped $NAME successfully!" log ${GREEN} ${WHITE}
}

# Restart a service
__restart() {
	__stop
	__start
	if [ "$RET" = "0" ]; then
		echo "Restarted" > "/var/run/leaninit/$__svcname.status"
	fi
	return $RET
}

# Reload a service
__reload() {
	print "Reloading $NAME..." log ${BLUE} ${WHITE}
	reload
	RET=$?
	if [ $RET = 0 ]; then
		print "Successfully reloaded $NAME!" log ${GREEN} ${WHITE}
		echo "Reloaded" > "/var/run/leaninit/$__svcname.status"
	else
		print "Failed to reload $NAME!" log ${RED}
	fi
	return $RET
}

# Get the current status of a service
__status() {
	if [ -r "/etc/leaninit.d/svc.e/$__svcname" ]; then
		STAT=enabled
	else
		STAT=disabled
	fi
	if [ ! -r "/var/run/leaninit/$__svcname.status" ]; then
		print "$NAME ($STAT) is not running..." nolog ${PURPLE} ${WHITE}
	else
		print "$NAME ($STAT) has the status of: $(cat /var/run/leaninit/$__svcname.status)" nolog ${PURPLE} ${WHITE}
	fi
}

# Run function for directly executing init scripts
run() {

	# Set $__svcname to $1
	__svcname=$1

	# Init scripts must be given two arguments
	if [ ! -n "$2" ]; then
		__usage
	fi

	# If the service does not support the current OS, exit
	if [ -n "$TARGET" ] && [ "$TARGET" != "$(uname)" ]; then
		print "$NAME is not compatible with $(uname)!" nolog ${RED}
		exit 5
	fi

	# Handle arguments
	case $2 in
		enable)
			__rootcheck
			__oscheck enable
			if [ -r "/etc/leaninit.d/svc.e/$__svcname" ]; then
				print "$NAME is already enabled..." nolog ${PURPLE} ${YELLOW}
				exit 0
			fi
			if [ -n "$TYPE" ] && [ -r "/etc/leaninit.d/svc.e/$TYPE.type" ]; then
				print "$NAME could not be enabled because $(cat /etc/leaninit.d/svc.e/$TYPE.type) conflicts with $NAME!" log ${RED}
				exit 1
			fi
			touch "/etc/leaninit.d/svc.e/$__svcname"
			if [ -n "$TYPE" ]; then
				echo "$__svcname" > "/etc/leaninit.d/svc.e/$TYPE.type"
			fi
			print "$NAME has been enabled!" log ${GREEN} ${WHITE}
			exifex enable ;;
		disable)
			__rootcheck
			__oscheck disable
			if [ ! -r "/etc/leaninit.d/svc.e/$__svcname" ]; then
				print "$NAME is already disabled..." nolog ${PURPLE} ${YELLOW}
				exit 0
			fi
			rm "/etc/leaninit.d/svc.e/$__svcname"
			if [ -n "$TYPE" ]; then
				rm "/etc/leaninit.d/svc.e/$TYPE.type"
			fi
			if [ $? != 0 ]; then
				print "Could not disable $NAME!" log ${RED}
				exit 1
			fi
			print "$NAME has been disabled!" log ${GREEN} ${WHITE}
			exifex disable ;;
		start)
			__start ;;
		stop)
			__stop ;;
		restart)
			__restart ;;
		try-restart)
			__svccheck
			__restart ;;
		reload)
			__rootcheck
			__svccheck
			type reload >> /dev/null
			if [ $? = 0 ]; then
				__reload
			else
				print "$NAME cannot be reloaded!" log ${RED}
				exit 3
			fi ;;
		force-reload)
			__rootcheck
			__svccheck
			type reload >> /dev/null
			if [ $? = 0 ]; then
				__reload
			else
				print "Forcing $NAME to restart..." log ${BLUE} ${WHITE}
				__restart
			fi ;;
		status)
			__status ;;
DEFBSD
		info)
			__rootcheck
			if [ ! -n "$DAEMON" ]; then
				print "$NAME does not have a process to send the SIGINFO signal to!" nolog ${RED}
				exit 1
			fi
			print "Sending SIGINFO to $NAME (process name $DAEMON)..." nolog ${PURPLE} ${WHITE}
			pkill -INFO -x "$DAEMON" ;;
ENDEF
		*)
			echo "Illegal action - $2"
			__usage ;;
	esac
	exit $?
}
